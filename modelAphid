function aphidData = modelAphid(T, N)
%N = 30; %number of aphids desired
r = 2; %radius of experimental arena, in cm
%T = 30; %number of desired timesteps

%bloody ridiculous constants needed for the model, all from pea aphid paper
psmNaught = 0.1587;
psmInfinite = 0.3552;
dsm = 0.79; %in cm
changesm = 7.39; %in cm

pmsNaught = 0.5508;
pmsInfinite = 0.128;
dms = 1.34; %in cm

lNaught = 0.03; %in cm
lInfinite = 0.13; %in cm
dl = 0.74; %in cm

rhoNaught = 0.1387;
rhoInfinite = 0.9013;
drho = 0.44; %in cm

%INITIALISE THE APHIDS
%aphids by (1) angle, (2) length, (3) boolean indicated stopped (0) or moving
%(1), (4) rectangular coordinates in form x + yi, (5) direction of motion
%from the horizontal (sum of angles)
aphids = zeros(N, 5);
aphids(:, 1) = r*rand(N, 1);
aphids(:, 2) = 2*pi*rand(N, 1);
%about half of aphids start moving, half start stopped
vec = zeros(N, 1);
aphidNumbers = zeros(N, 1); %vector to count the aphids, gets stuck into the big matrix each frame
for i = 1:N %loop to build vector for stopped/moving, also to put in rectangular coordinates
    aphidNumbers(i) = i;
    x = aphids(i, 1)*sin(aphids(i, 2));
    y = aphids(i, 1)*cos(aphids(i, 2));
    aphids(i, 4) = x + y*1i;
    bool = rand > 0.5; %elegant solution from http://kr.mathworks.com/matlabcentral/newsreader/view_thread/336582
    vec(i) = bool;
end

aphids(:, 3) = vec;
aphids(:, 5) = vec; %only one angle so far, so same as objective

plotAphids(aphids(:, 4), r);
aphidData = zeros(N, 4); %filling in first frame into aphidData
aphidData(:, 1) = aphidNumbers;
aphidData(:, 2) = ones(N, 1); %because this is just for the first frame
aphidData(:, 3) = real(aphids(:, 4));
aphidData(:, 4) = imag(aphids(:, 4));

for t = 1:(T-1)
    newFrame = zeros(N, 4);
    newFrame(:, 1) = aphidNumbers; %count of all the different aphids
    newFrame(:, 2) = (t+1)*ones(N, 1); %frame numbers
    
    %initialise distance matrix
    [Z1,Z2] = meshgrid(aphids(:,4),aphids(:,4));
    dist = abs(Z2-Z1);
    %set diagonal to 2*radius+1 length, so 0 diagonal won't trip up nearest
    %neighbor find
    dist(logical(eye(size(dist)))) = 2*r+1;
    
    %APHIDS RECALCULATING
    for i = 1:N
        d = min(dist(:, i));
        
        %determine if each aphid is going to move this round
        if aphids(i, 3) == 0 %if the aphid is stopped...
            probChange = psmNaught * exp(-d/dsm)+psmInfinite*(d/(d+changesm)); %psm(d)
            bool = rand > probChange;
            if bool
                aphids(i, 3) = 1;
            end
        else %if the aphid is moving
            probChange = pmsInfinite+(pmsNaught-pmsInfinite)*exp(-d/dms);%pms(d)
            bool = rand > probChange;
            if bool
                aphids(i, 3) = 0;
            end
        end
        
        
        
        
        %if the aphid is going to move, determine angle and distance, update
        %coords
        if aphids(i,3) == 1
            length = lInfinite + (lNaught - lInfinite)*exp(-d/dl);
            rho = rhoInfinite + (rhoNaught - rhoInfinite)*exp(-d/drho);
            
            aphids(i, 5) = aphids(i, 5) + rho;
            newX = real(aphids(i, 4)) + length*sin(aphids(i, 5));
            newY = imag(aphids(i, 4)) + length*cos(aphids(i, 5));
            
            %test if going outside circle, if so reflect
            if sqrt(newX^2 + newY^2) > r
                zi = aphids(i, 4);
                zf = newX+ 1i * newY;
                
                sample = 1000; % Number of points for numerical computations
                line = linspace(zf, zi, sample);
                
                theta = linspace(0,2*pi,sample);
                circle = r*exp(1i*theta);
                
                circle = [real(circle);imag(circle)];
                line = [real(line); imag(line)];
                
                pointIntersect = InterX(circle,line);
                
                tanAngle = 0;
                %find tangent line by finding point where it hits x axis
                %sides
                if (testEquality(pointIntersect(2),0, 0.001))
                    angle = atan((imag(zf) - imag(zi))/(real(zf)- real(zi)));
                    angleSign = (real(zf)-real(zi))/abs(real(zf)-real(zi)); %zf-zi is intentional, not a typo
                    if pointIntersect(1) < 0
                        k = -1;
                        c = 1;
                    else
                        k = 1;
                        c = -1;
                    end
                    %top&bottom
                elseif (testEquality(pointIntersect(1), 0, 0.001))
                    if (real(zf)- real(zi) == 0)
                        angle = pi/2; %because if it's going through the pole vertically, this is the ONLY angle you might want
                    else
                        angle = atan((imag(zf) - imag(zi))/(real(zf)- real(zi)));
                    end
                    
                    angleSign = real(zi) - real(zf);
                    if angleSign ~= 0
                        angleSign = angleSign/abs(real(zi) - real(zf));
                    end
                    
                    if angleSign > 0
                        k = -1;
                        c = 1;
                    else
                        k = 1;
                        c = 1;
                    end
                else
                    c = pointIntersect(1)/abs(pointIntersect(1)); %+1 in QI, QIV; -1 in QII, QIII
                    k = pointIntersect(1)*pointIntersect(2)/(abs(pointIntersect(1)*pointIntersect(2))); %+1 in QI, QIII; -1 in QII, QIV
                    
                    angle = atan(pointIntersect(2)/pointIntersect(1));
                    if (c < 0) %because arctan doesn't work in qII & qIII
                        angle = angle + pi;
                    end
                    h = r/cos(angle); %point of intersection of tan with x axis
                    mTangent = pointIntersect(2)/(pointIntersect(1) - h);
                    
                    mVector = (pointIntersect(2) - imag(zi))/(pointIntersect(1) - real(zi));
                    %find angle between vector and tangent line, for reflection
                    angle = abs(atan((mTangent - mVector)/(1 + mVector * mTangent)));
                    
                    %mTangent;
                    tanAngle = abs(atan(mTangent));
                    
                    %look at line perpendicular to tangent, see if the point the vector
                    %starts at falls above or below; this determines the equation used to
                    %find the angle of reflection
                    yProjected = (1/mTangent)*(pointIntersect(1) - real(zi)) + pointIntersect(2);
                    angleSign = (yProjected - imag(zi))/abs(yProjected - imag(zi));
                    
                end
                
                if testEquality(angleSign, 0, 0.001)
                    angleSign = 1;
                end
                
                if(k * angleSign > 0)
                    tanAngle = pi - tanAngle;
                end
                
                toHorizontal = angleSign * tanAngle + c * angleSign * angle;
                
                %find length of reflected segment
                %reflectLength = abs(zi-zf) - sqrt(real(zi)^2 + imag(zi)^2)
                reflectLength = abs(zi-zf) - sqrt((pointIntersect(1)-real(zi))^2 + (pointIntersect(2)- imag(zi))^2);
                
                %location of endpoint is angle&reflectLength away from origin,
                %transposed by the intersection point
                finalLocation = reflectLength*cos(toHorizontal) + 1i * reflectLength*sin(toHorizontal);
                finalLocation = finalLocation + pointIntersect(1) + 1i*pointIntersect(2);
                
                plotAphids(aphids(:, 4), r);
                pause(1);
                
                
                aphids(i, 4) = finalLocation;
                aphids(i, 1) = acos(real(finalLocation)/sqrt(real(finalLocation)^2 + real(finalLocation)^2));
                aphids(i, 5) = angle;
            else
                aphids(i, 4) = newX + 1i * newY;
                aphids(i, 1) = rho;
                aphids(i, 2) = length;
            end
        end
    end
    
    newFrame(:, 3) = real(aphids(:, 4));
    newFrame(:, 4) = imag(aphids(:, 4));
    aphidData = [aphidData; newFrame];
    
end
end

function plotAphids(coords, r)
coordsX = real(coords);
coordsY = imag(coords);

theta = linspace(0,2*pi,1000);
circle = r*exp(1i*theta);

% plots current frame
scatter(coordsX, coordsY, 'filled');
title(strcat('Aphids'));
axis([-r r -r r]);
hold on; plot(circle,'b-'); hold off;
end


% From Matlab file exchange
function P = InterX(L1,varargin)
%INTERX Intersection of curves
%   P = INTERX(L1,L2) returns the intersection points of two curves L1
%   and L2. The curves L1,L2 can be either closed or open and are described
%   by two-row-matrices, where each row contains its x- and y- coordinates.
%   The intersection of groups of curves (e.g. contour lines, multiply
%   connected regions etc) can also be computed by separating them with a
%   column of NaNs as for example
%
%         L  = [x11 x12 x13 ... NaN x21 x22 x23 ...;
%               y11 y12 y13 ... NaN y21 y22 y23 ...]
%
%   P has the same structure as L1 and L2, and its rows correspond to the
%   x- and y- coordinates of the intersection points of L1 and L2. If no
%   intersections are found, the returned P is empty.
%
%   P = INTERX(L1) returns the self-intersection points of L1. To keep
%   the code simple, the points at which the curve is tangent to itself are
%   not included. P = INTERX(L1,L1) returns all the points of the curve
%   together with any self-intersection points.
%
%   Example:
%       t = linspace(0,2*pi);
%       r1 = sin(4*t)+2;  x1 = r1.*cos(t); y1 = r1.*sin(t);
%       r2 = sin(8*t)+2;  x2 = r2.*cos(t); y2 = r2.*sin(t);
%       P = InterX([x1;y1],[x2;y2]);
%       plot(x1,y1,x2,y2,P(1,:),P(2,:),'ro')

%   Author : NS
%   Version: 3.0, 21 Sept. 2010

%   Two words about the algorithm: Most of the code is self-explanatory.
%   The only trick lies in the calculation of C1 and C2. To be brief, this
%   is essentially the two-dimensional analog of the condition that needs
%   to be satisfied by a function F(x) that has a zero in the interval
%   [a,b], namely
%           F(a)*F(b) <= 0
%   C1 and C2 exactly do this for each segment of curves 1 and 2
%   respectively. If this condition is satisfied simultaneously for two
%   segments then we know that they will cross at some point.
%   Each factor of the 'C' arrays is essentially a matrix containing
%   the numerators of the signed distances between points of one curve
%   and line segments of the other.

%...Argument checks and assignment of L2
error(nargchk(1,2,nargin));
if nargin == 1,
    L2 = L1;    hF = @lt;   %...Avoid the inclusion of common points
else
    L2 = varargin{1}; hF = @le;
end

%...Preliminary stuff
x1  = L1(1,:)';  x2 = L2(1,:);
y1  = L1(2,:)';  y2 = L2(2,:);
dx1 = diff(x1); dy1 = diff(y1);
dx2 = diff(x2); dy2 = diff(y2);

%...Determine 'signed distances'
S1 = dx1.*y1(1:end-1) - dy1.*x1(1:end-1);
S2 = dx2.*y2(1:end-1) - dy2.*x2(1:end-1);

C1 = feval(hF,D(bsxfun(@times,dx1,y2)-bsxfun(@times,dy1,x2),S1),0);
C2 = feval(hF,D((bsxfun(@times,y1,dx2)-bsxfun(@times,x1,dy2))',S2'),0)';

%...Obtain the segments where an intersection is expected
[i,j] = find(C1 & C2);
if isempty(i),P = zeros(2,0);return; end;

%...Transpose and prepare for output
i=i'; dx2=dx2'; dy2=dy2'; S2 = S2';
L = dy2(j).*dx1(i) - dy1(i).*dx2(j);
i = i(L~=0); j=j(L~=0); L=L(L~=0);  %...Avoid divisions by 0

%...Solve system of eqs to get the common points
P = unique([dx2(j).*S1(i) - dx1(i).*S2(j), ...
    dy2(j).*S1(i) - dy1(i).*S2(j)]./[L L],'rows')';

    function u = D(x,y)
        u = bsxfun(@minus,x(:,1:end-1),y).*bsxfun(@minus,x(:,2:end),y);
    end
end

%for float/double equality testing
function bool = testEquality (argOne, argTwo, epsilon)
bool = (argOne < argTwo + epsilon) && (argOne > argTwo - epsilon);
end
